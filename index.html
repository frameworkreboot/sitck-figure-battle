<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medieval Stick Figure Battle</title>
    <style>
        /* CSS Styles remain the same as before */
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative; /* Needed for absolute positioning of message box */
            width: 95%;
            max-width: 900px; /* Limit max width */
        }
        #ui-top {
            width: 100%;
            padding: 10px;
            background-color: #e0e0e0;
            border-bottom: 1px solid #ccc;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #resource-display {
            font-weight: bold;
        }
        #gameCanvas {
            border: 1px solid #000;
            cursor: crosshair;
            background-color: #fafad2; /* Light Goldenrod Yellow - ground color */
            display: block; /* Prevent extra space below canvas */
            width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            max-height: 600px; /* Limit max height */
            aspect-ratio: 800 / 500; /* Maintain aspect ratio based on original config */
        }
        #ui-bottom {
            width: 100%;
            padding: 10px;
            background-color: #e0e0e0;
            border-top: 1px solid #ccc;
            box-sizing: border-box;
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center;
            gap: 5px; /* Spacing between buttons */
        }
        button {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #a9a9a9; /* Dark Gray */
            color: white;
            border: 1px solid #808080;
            border-radius: 5px;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button:hover {
            background-color: #8c8c8c;
        }
        button:active {
            background-color: #707070;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        button.selected {
            background-color: #6a5acd; /* Slate Blue */
            border-color: #483d8b;
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 1.5em;
            text-align: center;
            z-index: 100; /* Ensure it's above the canvas */
            display: none; /* Hidden by default */
        }
        #save-load button {
             margin-left: 10px;
             background-color: #4682b4; /* Steel Blue */
             border-color: #4169e1;
        }
        #save-load button:hover {
             background-color: #5f9ea0; /* Cadet Blue */
        }
    </style>
</head>
<body>
    <h1>Medieval Stick Figure Battle (MVP)</h1>

    <div id="game-container">
        <div id="ui-top">
            <div id="resource-display">Gold: 100</div>
            <div id="save-load">
                <button onclick="game.saveGame()">Save</button>
                <button onclick="game.loadGame()">Load</button>
                 <button onclick="game.resetGame()">Reset</button>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas> <div id="ui-bottom">
            <button id="build-worker-btn" onclick="game.selectTrainUnit('Worker')">Train Worker (10G)</button>
            <button id="build-soldier-btn" onclick="game.selectTrainUnit('Soldier')">Train Soldier (20G)</button>
            <button id="build-archer-btn" onclick="game.selectTrainUnit('Archer')">Train Archer (25G)</button>
            <button id="build-wall-btn" onclick="game.selectBuild('Wall')">Build Wall (15G)</button>
            <button id="build-tower-btn" onclick="game.selectBuild('Tower')">Build Tower (50G)</button>
            <button id="build-barracks-btn" onclick="game.selectBuild('Barracks')">Build Barracks (75G)</button>
            <button id="build-mine-btn" onclick="game.selectBuild('Mine')">Build Mine (40G)</button>
        </div>

        <div id="message-box">Game Over!</div>
    </div>

    <script>
        console.log("Script execution started."); // DEBUG

        // --- Game Configuration ---
        const CONFIG = {
            CANVAS_WIDTH: 800, CANVAS_HEIGHT: 500, UNIT_SIZE: 10, BUILDING_BASE_SIZE: 30,
            STICK_FIGURE_COLOR_PLAYER: 'blue', STICK_FIGURE_COLOR_AI: 'red',
            BUILDING_COLOR_PLAYER: 'darkblue', BUILDING_COLOR_AI: 'darkred',
            SELECTION_COLOR: 'lime', HEALTH_BAR_COLOR: 'green', HEALTH_BAR_BACKGROUND: 'grey',
            HEALTH_BAR_HEIGHT: 4, BUILD_PREVIEW_COLOR: 'rgba(0, 255, 0, 0.5)',
            STARTING_GOLD: 100, MINE_GOLD_RATE: 1, RESOURCE_INTERVAL: 2000,
            UNIT_STATS: {
                Worker:  { cost: 10, hp: 25, speed: 1.5, attack: 1, range: 5, type: 'worker' },
                Soldier: { cost: 20, hp: 50, speed: 1,   attack: 5, range: 15, type: 'melee' },
                Archer:  { cost: 25, hp: 30, speed: 1.2, attack: 3, range: 80, type: 'ranged' } },
            BUILDING_STATS: {
                Base:    { cost: 0,   hp: 500, size: 40, color: 'darkblue', provides_workers: true },
                Wall:    { cost: 15,  hp: 100, size: 20, color: 'grey' },
                Tower:   { cost: 50,  hp: 150, size: 25, color: 'saddlebrown', attack: 4, range: 100, attack_speed: 1500 },
                Barracks:{ cost: 75,  hp: 120, size: 35, color: 'olive', enables_combat_units: true },
                Mine:    { cost: 40,  hp: 80,  size: 30, color: 'gold', is_mine: true } },
            BUILDING_PLACEMENT_DISTANCE: 5, AI_STARTING_GOLD: 100, AI_BUILD_INTERVAL: 15000,
            AI_TRAIN_INTERVAL: 8000, AI_ATTACK_INTERVAL: 25000, AI_RESOURCE_INTERVAL: 2000,
            ATTACK_INTERVAL: 1000, PROJECTILE_SPEED: 5, PROJECTILE_COLOR: 'black', PROJECTILE_SIZE: 3,
            GAME_SPEED: 16 // Target FPS (used for timing calculations if needed, not directly limiting loop)
        };

        // --- Utility Functions ---
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function isColliding(rect1, rect2) { return ( rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y ); }

        // --- Game Classes ---
        class Entity {
            constructor(x, y, width, height, hp, owner, id_prefix = 'e') {
                this.id = `${id_prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                this.x = x; this.y = y; this.width = width; this.height = height;
                this.maxHp = hp; this.hp = hp; this.owner = owner; this.selected = false;
            }
            // Basic draw method (should be overridden)
            draw(ctx) { console.warn("Base draw method called for", this.id); }
            // Basic update method (should be overridden)
            update(deltaTime, gameEntities, projectiles) { }
            // Get center coordinates
            getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; }
            // Get bounding box for collision detection
            getBoundingBox() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            // Apply damage and check for death
            takeDamage(amount) { this.hp -= amount; if (this.hp <= 0) { this.hp = 0; console.log(`${this.owner} ${this.type || 'Entity'} ${this.id} destroyed.`); return true; } return false; }
            // Draw health bar if damaged
            drawHealthBar(ctx) { if (this.hp < this.maxHp && this.hp > 0) { const barWidth = this.width; const barX = this.x; const barY = this.y - CONFIG.HEALTH_BAR_HEIGHT - 2; const hpRatio = this.hp / this.maxHp; ctx.fillStyle = CONFIG.HEALTH_BAR_BACKGROUND; ctx.fillRect(barX, barY, barWidth, CONFIG.HEALTH_BAR_HEIGHT); ctx.fillStyle = CONFIG.HEALTH_BAR_COLOR; ctx.fillRect(barX, barY, barWidth * hpRatio, CONFIG.HEALTH_BAR_HEIGHT); } }
        }

        class Unit extends Entity {
            constructor(x, y, owner, type) {
                const stats = CONFIG.UNIT_STATS[type]; if (!stats) { throw new Error(`Invalid unit type: ${type}`); }
                super(x, y, CONFIG.UNIT_SIZE, CONFIG.UNIT_SIZE * 2, stats.hp, owner, type.charAt(0).toLowerCase());
                this.type = type; this.stats = stats; this.target = null; this.state = 'idle';
                this.attackCooldown = 0; this.miningCooldown = 0;
                this.color = owner === 'player' ? CONFIG.STICK_FIGURE_COLOR_PLAYER : CONFIG.STICK_FIGURE_COLOR_AI;
            }
            // Set movement or attack target
            setTarget(target) {
                this.target = target;
                if (target && typeof target.x !== 'undefined' && typeof target.y !== 'undefined') {
                    if (target instanceof Entity) { // Target is another entity
                        if (this.type === 'Worker' && target.stats?.is_mine && target.owner === this.owner) { this.state = 'moving_to_mine'; } // Worker targeting own mine
                        else if (target.owner !== this.owner) { this.state = 'moving_to_attack'; } // Targeting enemy
                        else { this.state = 'moving'; } // Targeting friendly or non-mine building
                    } else { this.state = 'moving'; } // Target is a coordinate
                } else { this.state = 'idle'; this.target = null; } // Invalid or no target
            }
            // Update unit state and position
            update(deltaTime, gameEntities, projectiles) {
                this.attackCooldown = Math.max(0, this.attackCooldown - deltaTime);
                this.miningCooldown = Math.max(0, this.miningCooldown - deltaTime);
                // State machine logic
                switch (this.state) {
                    case 'idle': if (this.type !== 'Worker') { this.findTarget(gameEntities); } break; // Non-workers look for targets
                    case 'moving':
                        if (!this.target) { this.state = 'idle'; break; } // Stop if target lost
                        const targetPosMove = this.target instanceof Entity ? this.target.getCenter() : this.target;
                        this.moveTowards(targetPosMove.x, targetPosMove.y);
                        // Stop if close enough to target position
                        if (distance(this.getCenter().x, this.getCenter().y, targetPosMove.x, targetPosMove.y) < this.stats.speed + 1) { this.state = 'idle'; this.target = null; } break;
                    case 'moving_to_mine':
                        if (!this.target || this.target.hp <= 0 || !this.target.stats?.is_mine) { this.state = 'idle'; this.target = null; break; } // Stop if mine invalid
                        const mineCenter = this.target.getCenter();
                        // Stop moving and start mining when close enough
                        if (distance(this.getCenter().x, this.getCenter().y, mineCenter.x, mineCenter.y) < this.target.width / 2 + this.width) { this.state = 'mining'; }
                        else { this.moveTowards(mineCenter.x, mineCenter.y); } break;
                    case 'mining':
                        if (!this.target || this.target.hp <= 0 || !this.target.stats?.is_mine) { this.state = 'idle'; this.target = null; break; } // Stop if mine invalid
                        // Add gold periodically
                        if (this.miningCooldown <= 0) { game.addGold(CONFIG.MINE_GOLD_RATE, this.owner); this.miningCooldown = CONFIG.RESOURCE_INTERVAL; } break;
                    case 'moving_to_attack':
                        if (!this.target || this.target.hp <= 0 || this.target.owner === this.owner) { this.state = 'idle'; this.target = null; this.findTarget(gameEntities); break; } // Stop if target invalid/friendly
                        const targetCenterMoveAttack = this.target.getCenter();
                        const distToTargetMoveAttack = distance(this.getCenter().x, this.getCenter().y, targetCenterMoveAttack.x, targetCenterMoveAttack.y);
                        // Stop moving and start attacking when in range
                        if (distToTargetMoveAttack <= this.stats.range - this.width / 2) { this.state = 'attacking'; }
                        else { this.moveTowards(targetCenterMoveAttack.x, targetCenterMoveAttack.y); } break;
                    case 'attacking':
                        if (!this.target || this.target.hp <= 0 || this.target.owner === this.owner) { this.state = 'idle'; this.target = null; this.findTarget(gameEntities); break; } // Stop if target invalid/friendly
                        const targetCenterAttack = this.target.getCenter();
                        const distToTargetAttack = distance(this.getCenter().x, this.getCenter().y, targetCenterAttack.x, targetCenterAttack.y);
                        // If target moved out of range, chase it
                        if (distToTargetAttack > this.stats.range) { this.state = 'moving_to_attack'; break; }
                        // Attack periodically
                        if (this.attackCooldown <= 0) { this.performAttack(projectiles); this.attackCooldown = CONFIG.ATTACK_INTERVAL; } break;
                }
            }
            // Find the closest enemy target within sight range
            findTarget(entities) {
                if (this.state !== 'idle') return; let closestEnemy = null; let minDistance = Infinity; const sightRange = this.stats.range * 2;
                entities.forEach(entity => { if (entity.owner !== this.owner && entity.hp > 0 && (entity instanceof Unit || entity instanceof Building)) { const d = distance(this.getCenter().x, this.getCenter().y, entity.getCenter().x, entity.getCenter().y); if (d < sightRange && d < minDistance) { minDistance = d; closestEnemy = entity; } } });
                if (closestEnemy) { this.setTarget(closestEnemy); } // Set target if found
            }
            // Move towards a target coordinate
            moveTowards(targetX, targetY) {
                const moveSpeed = this.stats.speed; const center = this.getCenter(); const dx = targetX - center.x; const dy = targetY - center.y; const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > moveSpeed) { // Only move if distance is greater than speed
                    const moveX = (dx / dist) * moveSpeed; const moveY = (dy / dist) * moveSpeed; this.x += moveX; this.y += moveY;
                }
                // Clamp position to stay within canvas bounds
                this.x = Math.max(0, Math.min(CONFIG.CANVAS_WIDTH - this.width, this.x)); this.y = Math.max(0, Math.min(CONFIG.CANVAS_HEIGHT - this.height, this.y));
            }
            // Perform attack (melee or ranged)
            performAttack(projectiles) {
                if (!this.target || this.target.hp <= 0) return; // Double-check target validity
                if (this.stats.type === 'ranged') { // Ranged units create projectiles
                    const startPos = this.getCenter(); const targetPos = this.target.getCenter();
                    if (projectiles && typeof projectiles.push === 'function') {
                       projectiles.push(new Projectile(startPos.x, startPos.y, targetPos.x, targetPos.y, this.stats.attack, this.owner, this.target));
                    } else { console.error("Projectiles array is invalid in performAttack"); }
                } else { // Melee units deal direct damage
                    const isDead = this.target.takeDamage(this.stats.attack); if (isDead) { this.state = 'idle'; this.target = null; } // Go idle if target died
                }
            }
            // Draw the stick figure unit
            draw(ctx) {
                if (!ctx) { console.error("No context for drawing unit", this.id); return; }
                ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.beginPath();
                const headRadius = this.width / 2; const bodyTopY = this.y + headRadius * 2; const bodyBottomY = this.y + this.height * 0.8; const neckY = this.y + headRadius; const centerX = this.x + headRadius;
                // Draw parts
                ctx.arc(centerX, neckY, headRadius, 0, Math.PI * 2); // Head
                ctx.moveTo(centerX, bodyTopY); ctx.lineTo(centerX, bodyBottomY); // Body
                ctx.moveTo(centerX, bodyBottomY); ctx.lineTo(this.x, this.y + this.height); // Left Leg
                ctx.moveTo(centerX, bodyBottomY); ctx.lineTo(this.x + this.width, this.y + this.height); // Right Leg
                const armY = this.y + this.height * 0.5; ctx.moveTo(this.x, armY); ctx.lineTo(this.x + this.width, armY); // Arms
                ctx.stroke();
                // Health bar and selection indicator
                this.drawHealthBar(ctx);
                if (this.selected) { ctx.strokeStyle = CONFIG.SELECTION_COLOR; ctx.lineWidth = 1; ctx.strokeRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4); }
                // Target line if moving
                if ((this.state === 'moving' || this.state === 'moving_to_attack' || this.state === 'moving_to_mine') && this.target) { ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.getCenter().x, this.getCenter().y); const targetPosLine = this.target instanceof Entity ? this.target.getCenter() : this.target; ctx.lineTo(targetPosLine.x, targetPosLine.y); ctx.stroke(); }
            }
        }

        class Building extends Entity {
            constructor(x, y, owner, type) {
                const stats = CONFIG.BUILDING_STATS[type]; if (!stats) { throw new Error(`Invalid building type: ${type}`); }
                super(x, y, stats.size, stats.size, stats.hp, owner, type.charAt(0).toLowerCase());
                this.type = type; this.stats = stats; this.color = stats.color || (owner === 'player' ? CONFIG.BUILDING_COLOR_PLAYER : CONFIG.BUILDING_COLOR_AI);
                this.is_mine = stats.is_mine ?? false; this.provides_workers = stats.provides_workers ?? false; this.enables_combat_units = stats.enables_combat_units ?? false; this.attackCooldown = 0;
            }
            // Update building state (e.g., tower attacks)
            update(deltaTime, gameEntities, projectiles) {
                // Tower attack logic
                if (this.type === 'Tower' && this.hp > 0 && this.stats.attack && this.stats.range) {
                    this.attackCooldown = Math.max(0, this.attackCooldown - deltaTime);
                    if (this.attackCooldown <= 0) {
                        let target = null; let minDist = this.stats.range;
                        // Find closest enemy unit in range
                        gameEntities.forEach(entity => { if (entity instanceof Unit && entity.owner !== this.owner && entity.hp > 0) { const d = distance(this.getCenter().x, this.getCenter().y, entity.getCenter().x, entity.getCenter().y); if (d < minDist) { minDist = d; target = entity; } } });
                        // Fire projectile if target found
                        if (target) { const startPos = this.getCenter(); const targetPos = target.getCenter(); if (projectiles && typeof projectiles.push === 'function') { projectiles.push(new Projectile(startPos.x, startPos.y, targetPos.x, targetPos.y, this.stats.attack, this.owner, target)); this.attackCooldown = this.stats.attack_speed || 1500; } else { console.error("Projectiles array is invalid in Building update"); } }
                    }
                }
            }
            // Draw the building
            draw(ctx) {
                if (!ctx) { console.error("No context for drawing building", this.id); return; }
                ctx.fillStyle = this.color; ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
                // Draw basic rectangle
                ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height);
                // Draw symbol inside
                ctx.fillStyle = 'white'; ctx.font = '10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; let symbol = '?';
                switch(this.type) { case 'Base': symbol = 'B'; break; case 'Wall': symbol = ''; break; case 'Tower': symbol = 'T'; break; case 'Barracks': symbol = 'R'; break; case 'Mine': symbol = 'M'; break; default: symbol = this.type.charAt(0); }
                if (symbol) { ctx.fillText(symbol, this.x + this.width / 2, this.y + this.height / 2); }
                // Health bar and selection
                this.drawHealthBar(ctx);
                if (this.selected) { ctx.strokeStyle = CONFIG.SELECTION_COLOR; ctx.lineWidth = 1; ctx.strokeRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4); }
            }
        }

        class Projectile extends Entity {
             constructor(startX, startY, targetX, targetY, damage, owner, targetEntity) {
                super(startX, startY, CONFIG.PROJECTILE_SIZE, CONFIG.PROJECTILE_SIZE, 1, owner, 'p'); // HP is just for tracking lifetime
                this.damage = damage; this.startX = startX; this.startY = startY; this.targetEntity = targetEntity; // Store reference to target
                // Calculate velocity vector
                const dx = targetX - startX; const dy = targetY - startY; const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy)); // Avoid division by zero
                this.velocityX = (dx / dist) * CONFIG.PROJECTILE_SPEED; this.velocityY = (dy / dist) * CONFIG.PROJECTILE_SPEED;
                this.color = CONFIG.PROJECTILE_COLOR; this.maxRange = 2000; // Max travel distance
             }
             // Update projectile position and check for collisions/lifetime end
             update(deltaTime, gameEntities, projectiles) {
                 this.x += this.velocityX; this.y += this.velocityY; // Move projectile
                 // Check collision with its specific target
                 if (this.targetEntity && this.targetEntity.hp > 0) { if (isColliding(this.getBoundingBox(), this.targetEntity.getBoundingBox())) { this.targetEntity.takeDamage(this.damage); this.hp = 0; return; } } // Hit target
                 // Check if out of bounds or traveled too far
                 const distTraveled = distance(this.startX, this.startY, this.x, this.y);
                 if (this.x < -this.width || this.x > CONFIG.CANVAS_WIDTH || this.y < -this.height || this.y > CONFIG.CANVAS_HEIGHT || distTraveled > this.maxRange) { this.hp = 0; } // Mark for removal
             }
             // Draw the projectile (simple circle)
             draw(ctx) { if (!ctx) { console.error("No context for drawing projectile", this.id); return; } ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2); ctx.fill(); }
        }

        // --- Main Game Class ---
        class Game {
            constructor(canvasId) {
                console.log("Initializing Game class...");
                // Get canvas and context, crucial checks
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) { console.error(`Canvas element with ID "${canvasId}" not found!`); alert(`Fatal Error: Canvas element with ID "${canvasId}" not found! Check the HTML.`); return; }
                this.ctx = this.canvas.getContext('2d');
                 if (!this.ctx) { console.error(`Failed to get 2D context for canvas "${canvasId}"!`); alert(`Fatal Error: Failed to get 2D context for canvas "${canvasId}"! Your browser might not support Canvas.`); return; }

                // Get UI elements
                this.resourceDisplay = document.getElementById('resource-display');
                this.messageBox = document.getElementById('message-box');
                this.buildButtons = { Wall: document.getElementById('build-wall-btn'), Tower: document.getElementById('build-tower-btn'), Barracks: document.getElementById('build-barracks-btn'), Mine: document.getElementById('build-mine-btn'), };
                this.trainButtons = { Worker: document.getElementById('build-worker-btn'), Soldier: document.getElementById('build-soldier-btn'), Archer: document.getElementById('build-archer-btn'), };

                // Warn if UI elements are missing
                if (!this.resourceDisplay) console.warn("Resource display element not found."); if (!this.messageBox) console.warn("Message box element not found."); Object.entries(this.buildButtons).forEach(([key, value]) => { if (!value) console.warn(`Build button for ${key} not found.`); }); Object.entries(this.trainButtons).forEach(([key, value]) => { if (!value) console.warn(`Train button for ${key} not found.`); });

                // Set canvas resolution and handle resizing
                this.setCanvasResolution();
                window.addEventListener('resize', () => this.setCanvasResolution());

                // Initialize game state variables
                this.entities = []; this.projectiles = []; this.playerGold = 0; this.aiGold = 0;
                this.selectedUnits = []; this.buildingToPlace = null; this.unitToTrain = null; // unitToTrain not really used now
                this.mousePos = { x: 0, y: 0 }; this.isDragging = false; this.dragStartPos = { x: 0, y: 0 };
                this.gameOver = true; // Start as game over until reset
                this.winner = null; this.aiTimer = null; this.lastTimestamp = 0; this.gameLoopRequestId = null;

                // Attach input event listeners
                this.attachInputHandlers();
                // Reset game state and start the loop
                this.resetGame();
                console.log("Game class initialized.");
            }

            // Attach mouse event listeners to the canvas
            attachInputHandlers() {
                console.log("Attaching input handlers...");
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent right-click menu
                 console.log("Input handlers attached.");
            }

            // Set internal canvas resolution
            setCanvasResolution() {
                this.canvas.width = CONFIG.CANVAS_WIDTH; this.canvas.height = CONFIG.CANVAS_HEIGHT;
                console.log(`Canvas internal resolution set to: ${this.canvas.width}x${this.canvas.height}`);
                // Re-render immediately after resize if game is running
                if (this.ctx && !this.gameOver) { this.render(); }
            }

            // Reset the game to its initial state
            resetGame() {
                console.log("Resetting game state...");
                // Stop existing loop and timers
                if (this.gameLoopRequestId) cancelAnimationFrame(this.gameLoopRequestId);
                if (this.aiTimer) clearInterval(this.aiTimer);

                // Clear game objects and reset state
                this.entities = []; this.projectiles = []; this.playerGold = CONFIG.STARTING_GOLD; this.aiGold = CONFIG.AI_STARTING_GOLD;
                this.selectedUnits = []; this.buildingToPlace = null; this.unitToTrain = null;
                this.gameOver = false; // Game is now active
                this.winner = null; this.hideMessage(); this.updateResourceDisplay(); this.clearButtonSelections();

                // Create starting entities (bases, workers)
                try {
                    const playerBaseX = 50; const playerBaseY = CONFIG.CANVAS_HEIGHT / 2 - CONFIG.BUILDING_STATS.Base.size / 2;
                    this.entities.push(new Building(playerBaseX, playerBaseY, 'player', 'Base'));
                    const aiBaseX = CONFIG.CANVAS_WIDTH - 50 - CONFIG.BUILDING_STATS.Base.size; const aiBaseY = CONFIG.CANVAS_HEIGHT / 2 - CONFIG.BUILDING_STATS.Base.size / 2;
                    this.entities.push(new Building(aiBaseX, aiBaseY, 'ai', 'Base'));
                    this.entities.push(new Unit(playerBaseX + 50, playerBaseY + 10, 'player', 'Worker')); this.entities.push(new Unit(playerBaseX + 50, playerBaseY + 30, 'player', 'Worker'));
                    this.entities.push(new Unit(aiBaseX - 50, aiBaseY + 10, 'ai', 'Worker')); this.entities.push(new Unit(aiBaseX - 50, aiBaseY + 30, 'ai', 'Worker'));
                    console.log(`Initial entities created: ${this.entities.length}`);
                } catch (error) { console.error("Error creating initial entities:", error); this.showMessage("Error initializing game state!", 5000, true); this.gameOver = true; return; }

                // Start AI timer
                this.aiTimer = setInterval(() => this.runAI(), CONFIG.AI_TRAIN_INTERVAL);
                // Start the main game loop
                this.lastTimestamp = performance.now(); // Use high-precision timer
                // Use arrow function wrapper for requestAnimationFrame to preserve 'this'
                this.gameLoopRequestId = requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
                console.log("Game reset complete, loop started.");
            }

            // Calculate mouse position relative to canvas internal resolution
            getMousePos(event) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width; const scaleY = this.canvas.height / rect.height;
                // Handle both mouse and touch events
                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            }

            // Handle mouse button down events
            handleMouseDown(event) {
                 if (this.gameOver) return; // Ignore input if game over
                 this.mousePos = this.getMousePos(event);
                 // console.log(`Mouse Down at (${this.mousePos.x.toFixed(1)}, ${this.mousePos.y.toFixed(1)}), Button: ${event.button}`); // DEBUG
                 if (event.button === 0) { // Left click
                    this.isDragging = true; this.dragStartPos = { ...this.mousePos };
                    // If in build mode, try placing the building
                    if (this.buildingToPlace) { this.tryPlaceBuilding(this.mousePos.x, this.mousePos.y); }
                 } else if (event.button === 2) { // Right click
                      // Cancel build mode if active
                     if (this.buildingToPlace || this.unitToTrain) { this.buildingToPlace = null; this.unitToTrain = null; this.clearButtonSelections(); }
                     // Command selected units
                     else if (this.selectedUnits.length > 0) {
                         let targetEntity = null;
                         // Find entity under cursor
                         for (const entity of this.entities) { if (!entity.getBoundingBox) continue; const bb = entity.getBoundingBox(); if (this.mousePos.x >= bb.x && this.mousePos.x <= bb.x + bb.width && this.mousePos.y >= bb.y && this.mousePos.y <= bb.y + bb.height) { targetEntity = entity; break; } }
                         // Set target for each selected unit (entity or position)
                         this.selectedUnits.forEach(unit => { if (unit && unit.setTarget) { unit.setTarget(targetEntity || { ...this.mousePos }); } else { console.warn("Selected unit invalid or missing setTarget:", unit); } });
                     }
                 }
            }

            // Handle mouse movement (primarily for drag updates)
            handleMouseMove(event) {
                 if (this.gameOver || !this.isDragging) return; // Only update mouse position if dragging
                 this.mousePos = this.getMousePos(event);
                 // Render loop handles drawing drag rectangle/preview
            }

            // Handle mouse button up events (selection logic)
            handleMouseUp(event) {
                 if (this.gameOver) return; // Ignore input if game over
                 this.mousePos = this.getMousePos(event);
                 // console.log(`Mouse Up at (${this.mousePos.x.toFixed(1)}, ${this.mousePos.y.toFixed(1)}), Button: ${event.button}`); // DEBUG
                 if (event.button === 0) { // Left click up
                     // If dragging and not building, perform selection
                     if (this.isDragging && !this.buildingToPlace && !this.unitToTrain) {
                         const dragEndPos = this.mousePos;
                         const selectionRect = { x: Math.min(this.dragStartPos.x, dragEndPos.x), y: Math.min(this.dragStartPos.y, dragEndPos.y), width: Math.abs(this.dragStartPos.x - dragEndPos.x), height: Math.abs(this.dragStartPos.y - dragEndPos.y) };
                         // Deselect previously selected units
                         this.deselectAll();
                         // Check if it was a drag or a click
                         if (selectionRect.width > 5 || selectionRect.height > 5) { // Box selection
                             this.entities.forEach(entity => { if (entity instanceof Unit && entity.owner === 'player' && entity.getBoundingBox) { if (isColliding(entity.getBoundingBox(), selectionRect)) { entity.selected = true; this.selectedUnits.push(entity); } } });
                         } else { // Single click selection
                             let clickedEntity = null;
                             // Iterate backwards to select top-most entity
                             for (let i = this.entities.length - 1; i >= 0; i--) { const entity = this.entities[i]; if (!entity.getBoundingBox) continue; const bb = entity.getBoundingBox(); if (this.mousePos.x >= bb.x && this.mousePos.x <= bb.x + bb.width && this.mousePos.y >= bb.y && this.mousePos.y <= bb.y + bb.height) { clickedEntity = entity; break; } }
                             // Select if it's a player unit
                             if (clickedEntity && clickedEntity.owner === 'player') { clickedEntity.selected = true; if (clickedEntity instanceof Unit) { this.selectedUnits.push(clickedEntity); } }
                         }
                     }
                     this.isDragging = false; // End drag state
                 }
             }

            // Deselect all currently selected units
            deselectAll() { this.selectedUnits.forEach(unit => { if(unit) unit.selected = false; }); this.selectedUnits = []; }
            // Remove 'selected' class from all UI buttons
            clearButtonSelections() { Object.values(this.buildButtons).forEach(btn => { if(btn) btn.classList.remove('selected'); }); Object.values(this.trainButtons).forEach(btn => { if(btn) btn.classList.remove('selected'); }); this.buildingToPlace = null; this.unitToTrain = null; }
            // Add gold to player or AI
            addGold(amount, owner) { if (owner === 'player') { this.playerGold += amount; this.updateResourceDisplay(); } else { this.aiGold += amount; } }
            // Attempt to spend gold for player or AI
            spendGold(amount, owner) { if (owner === 'player') { if (this.playerGold >= amount) { this.playerGold -= amount; this.updateResourceDisplay(); return true; } } else { if (this.aiGold >= amount) { this.aiGold -= amount; return true; } } return false; }
            // Update the gold display in the UI
            updateResourceDisplay() { if (this.resourceDisplay) { this.resourceDisplay.textContent = `Gold: ${this.playerGold}`; } }

            // Enter build mode for a specific building type
            selectBuild(type) {
                 if (this.gameOver) return; this.clearButtonSelections(); this.buildingToPlace = type;
                 if(this.buildButtons[type]) { this.buildButtons[type].classList.add('selected'); } else { console.warn(`Button for building type ${type} not found.`); }
                 console.log(`Selected to build: ${type}`); // DEBUG
            }
            // Attempt to train a unit immediately on button click
            selectTrainUnit(type) {
                 if (this.gameOver) return; this.clearButtonSelections();
                 if(!this.trainButtons[type]) { console.warn(`Button for unit type ${type} not found.`); }
                 console.log(`Attempting to train: ${type}`); // DEBUG
                 this.tryTrainUnit(type); // Train immediately
            }

            // Check if a building can be placed at the given center coordinates
            canPlaceBuilding(type, centerX, centerY) {
                 const stats = CONFIG.BUILDING_STATS[type]; if (!stats) { console.error(`Invalid building type "${type}" in canPlaceBuilding`); return false; }
                 const size = stats.size; const buildX = centerX - size / 2; const buildY = centerY - size / 2; const buildingBox = { x: buildX, y: buildY, width: size, height: size };
                 // Check canvas boundaries
                 if (buildingBox.x < 0 || buildingBox.x + size > CONFIG.CANVAS_WIDTH || buildingBox.y < 0 || buildingBox.y + size > CONFIG.CANVAS_HEIGHT) { return false; }
                 // Check collision with existing buildings based on distance between centers
                 for (const entity of this.entities) { if (entity instanceof Building && entity.getCenter) { const existingCenter = entity.getCenter(); const existingSize = entity.width; const minDist = (size / 2) + (existingSize / 2) + CONFIG.BUILDING_PLACEMENT_DISTANCE; const d = distance(centerX, centerY, existingCenter.x, existingCenter.y); if (d < minDist) { return false; } } } return true; // Placement is valid
            }
            // Attempt to place the selected building at the mouse position
            tryPlaceBuilding(mouseX, mouseY) {
                 const type = this.buildingToPlace; if (!type) return; // Exit if not in build mode
                 const stats = CONFIG.BUILDING_STATS[type]; if (!stats) { console.error(`Invalid stats for building type "${type}"`); return; }
                 const buildX = mouseX - stats.size / 2; const buildY = mouseY - stats.size / 2; // Calculate top-left corner
                 // Check placement validity and resources
                 if (this.canPlaceBuilding(type, mouseX, mouseY)) {
                    if (this.spendGold(stats.cost, 'player')) {
                        console.log(`Placing ${type} at (${buildX.toFixed(1)}, ${buildY.toFixed(1)})`); // DEBUG
                        this.entities.push(new Building(buildX, buildY, 'player', type));
                        this.buildingToPlace = null; this.clearButtonSelections(); // Exit build mode on success
                    } else {
                        this.showMessage("Not enough gold!", 1000); this.buildingToPlace = null; this.clearButtonSelections(); // Exit build mode if not enough gold
                    }
                 }
                 else { this.showMessage("Cannot build here!", 1000); } // Keep build mode active if placement invalid
            }
            // Attempt to train a unit for the specified owner
            tryTrainUnit(type, owner = 'player') {
                 const stats = CONFIG.UNIT_STATS[type]; if (!stats) { console.error(`Invalid stats for unit type "${type}"`); return; }
                 // Find a required building (Base for Worker, Barracks for others)
                 let spawner = null; const requiredBuildingType = (type === 'Worker') ? 'Base' : 'Barracks';
                 for (const entity of this.entities) { if (entity instanceof Building && entity.owner === owner && entity.type === requiredBuildingType && entity.hp > 0) { spawner = entity; break; } }
                 // Check if spawner exists
                 if (!spawner) { if (owner === 'player') { this.showMessage(`Need a ${requiredBuildingType} to train ${type}!`, 1500); } return; }
                 // Check resources and spawn unit
                 if (this.spendGold(stats.cost, owner)) { const spawnX = spawner.x + spawner.width / 2; const spawnY = spawner.y + spawner.height + CONFIG.UNIT_SIZE / 2; const newUnit = new Unit(spawnX, spawnY, owner, type); this.entities.push(newUnit); }
                 else { if (owner === 'player') { this.showMessage(`Not enough gold for ${type}!`, 1000); } }
                 this.clearButtonSelections(); // Always clear button selection after attempt
            }

            // Simple AI logic (runs periodically)
            runAI() {
                 if (this.gameOver) return;
                 // --- AI State ---
                 const aiEntities = this.entities.filter(e => e.owner === 'ai'); const aiUnits = aiEntities.filter(e => e instanceof Unit && e.owner === 'ai'); const aiBuildings = aiEntities.filter(e => e instanceof Building && e.owner === 'ai');
                 const aiBase = aiBuildings.find(b => b.type === 'Base'); const aiBarracks = aiBuildings.find(b => b.type === 'Barracks'); const aiMines = aiBuildings.filter(b => b.type === 'Mine'); const aiWorkers = aiUnits.filter(u => u.type === 'Worker');

                 // --- AI Actions ---
                 // 1. Assign idle workers to mine
                 aiWorkers.forEach(worker => { if (worker.state === 'idle' && aiMines.length > 0) { const targetMine = aiMines[0]; if (targetMine && targetMine.hp > 0) { worker.setTarget(targetMine); } } });
                 // 2. Build basic structures
                 const mineCost = CONFIG.BUILDING_STATS.Mine.cost; const barracksCost = CONFIG.BUILDING_STATS.Barracks.cost; const shouldBuildMine = aiMines.length === 0 && this.aiGold >= mineCost; const shouldBuildBarracks = !aiBarracks && this.aiGold >= barracksCost;
                 if (shouldBuildMine || shouldBuildBarracks) { const builderWorker = aiWorkers.find(w => w.state === 'idle'); if (builderWorker && aiBase) { const baseCenter = aiBase.getCenter(); const buildType = shouldBuildMine ? 'Mine' : 'Barracks'; const stats = CONFIG.BUILDING_STATS[buildType]; const cost = stats.cost; let placed = false; for (let attempts = 0; attempts < 10; attempts++) { const angle = Math.random() * Math.PI * 2; const radius = 60 + Math.random() * 50; const buildCenterX = baseCenter.x + Math.cos(angle) * radius; const buildCenterY = baseCenter.y + Math.sin(angle) * radius; if (this.canPlaceBuilding(buildType, buildCenterX, buildCenterY)) { if (this.spendGold(cost, 'ai')) { const buildX = buildCenterX - stats.size / 2; const buildY = buildCenterY - stats.size / 2; this.entities.push(new Building(buildX, buildY, 'ai', buildType)); placed = true; break; } else { break; } } } } }
                 // 3. Train units (workers then soldiers)
                 const workerCost = CONFIG.UNIT_STATS.Worker.cost; const soldierCost = CONFIG.UNIT_STATS.Soldier.cost; const workerCount = aiWorkers.length; const combatUnitCount = aiUnits.length - workerCount;
                 if (workerCount < 5 && this.aiGold >= workerCost) { this.tryTrainUnit('Worker', 'ai'); } else if (aiBarracks && combatUnitCount < 15 && this.aiGold >= soldierCost) { this.tryTrainUnit('Soldier', 'ai'); }
                 // 4. Attack periodically with idle combat units
                 if (Math.random() < 0.1) { const combatUnits = aiUnits.filter(u => u.type !== 'Worker' && u.state === 'idle'); if (combatUnits.length >= 5) { const playerBase = this.entities.find(e => e.owner === 'player' && e.type === 'Base'); const targetPos = playerBase ? playerBase.getCenter() : { x: 50, y: CONFIG.CANVAS_HEIGHT / 2 }; combatUnits.forEach(unit => { if (unit && unit.setTarget) { unit.setTarget(targetPos); } }); } }
            }

            // Update game state (called every frame)
            update(deltaTime) {
                if (this.gameOver) return;
                // Update all entities
                this.entities.forEach(entity => { if (entity && entity.update) { entity.update(deltaTime, this.entities, this.projectiles); } });
                // Update all projectiles
                this.projectiles.forEach(p => { if (p && p.update) { p.update(deltaTime, this.entities, this.projectiles); } });
                // Remove dead entities/projectiles
                this.entities = this.entities.filter(entity => entity && entity.hp > 0);
                this.projectiles = this.projectiles.filter(p => p && p.hp > 0);
                // Update selection list
                this.selectedUnits = this.selectedUnits.filter(unit => unit && unit.hp > 0);
                // Check for win/loss conditions
                this.checkEndGame();
            }

            // Check if the game has ended (base destroyed)
            checkEndGame() {
                 const playerBase = this.entities.find(e => e.owner === 'player' && e.type === 'Base');
                 const aiBase = this.entities.find(e => e.owner === 'ai' && e.type === 'Base');
                 if (!playerBase) { this.endGame('AI'); } else if (!aiBase) { this.endGame('Player'); }
            }

            // Render the game state to the canvas (called every frame)
            render() {
                 if (!this.ctx) return; // Abort if context is invalid
                 // Clear canvas
                 this.ctx.fillStyle = '#fafad2'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                 // Draw entities (buildings first, then units)
                 this.entities.filter(e => e instanceof Building).forEach(entity => { if (entity && entity.draw) entity.draw(this.ctx); });
                 this.entities.filter(e => e instanceof Unit).forEach(entity => { if (entity && entity.draw) entity.draw(this.ctx); });
                 // Draw projectiles
                 this.projectiles.forEach(p => { if (p && p.draw) p.draw(this.ctx); });
                 // Draw building placement preview
                 if (this.buildingToPlace) { const stats = CONFIG.BUILDING_STATS[this.buildingToPlace]; if (stats) { const previewSize = stats.size; const previewX = this.mousePos.x - previewSize / 2; const previewY = this.mousePos.y - previewSize / 2; const canPlace = this.canPlaceBuilding(this.buildingToPlace, this.mousePos.x, this.mousePos.y); this.ctx.globalAlpha = 0.6; this.ctx.fillStyle = canPlace ? CONFIG.BUILD_PREVIEW_COLOR : 'rgba(255, 0, 0, 0.5)'; this.ctx.fillRect(previewX, previewY, previewSize, previewSize); this.ctx.strokeStyle = canPlace ? 'green' : 'red'; this.ctx.lineWidth = 1; this.ctx.strokeRect(previewX, previewY, previewSize, previewSize); this.ctx.globalAlpha = 1.0; } }
                 // Draw selection rectangle
                 if (this.isDragging && !this.buildingToPlace && !this.unitToTrain) { this.ctx.strokeStyle = CONFIG.SELECTION_COLOR; this.ctx.lineWidth = 1; this.ctx.strokeRect( this.dragStartPos.x, this.dragStartPos.y, this.mousePos.x - this.dragStartPos.x, this.mousePos.y - this.dragStartPos.y ); }
            }

            // Main game loop, driven by requestAnimationFrame
            gameLoop(timestamp) {
                // 'this' context is preserved because this method is called via the arrow function wrapper
                if (this.gameOver) {
                     console.log("Game loop halting."); this.gameLoopRequestId = null; return; // Stop loop if game over
                }
                // Calculate time elapsed since last frame
                const deltaTime = timestamp - this.lastTimestamp; this.lastTimestamp = timestamp;
                // Cap delta time to prevent large jumps if tab loses focus
                const effectiveDeltaTime = Math.min(deltaTime, 100); // Max 100ms step
                // Update and render game state
                try { this.update(effectiveDeltaTime); this.render(); }
                catch (error) { console.error("Error in game loop:", error); this.showMessage("An error occurred! See console.", 5000, true); this.gameOver = true; } // Stop game on error
                // Request the next animation frame, using arrow function wrapper
                this.gameLoopRequestId = requestAnimationFrame((ts) => this.gameLoop(ts));
            }

            // End the game and declare winner
            endGame(winner) {
                 if (this.gameOver) return; // Prevent multiple calls
                 this.gameOver = true; this.winner = winner;
                 console.log(`Game Over! Winner: ${winner}`); this.showMessage(`${winner} Wins!`, 5000, true); // Show persistent message
                 // Stop AI timer
                 if (this.aiTimer) clearInterval(this.aiTimer); this.aiTimer = null;
                 // Game loop will stop itself on the next iteration check
            }
            // Display a message on the screen
            showMessage(text, duration = 2000, persist = false) { if (this.messageBox) { this.messageBox.textContent = text; this.messageBox.style.display = 'block'; if (!persist) { setTimeout(() => { this.hideMessage(); }, duration); } } else { console.warn("Cannot show message, messageBox element not found."); } }
            // Hide the on-screen message
            hideMessage() { if (this.messageBox) { this.messageBox.style.display = 'none'; } }

            // Save game state to localStorage
            saveGame() {
                 if (this.gameOver && this.winner) { this.showMessage("Cannot save finished game", 1500); return; } // Don't save finished games
                 try {
                    // Serialize necessary entity data
                    const entityData = this.entities.map(e => { if (!e || !e.type || !e.owner) return null; return { type: e.type, owner: e.owner, x: e.x, y: e.y, hp: e.hp, state: e.state, /* Add target? */ }; }).filter(e => e !== null);
                    // Create save object
                    const saveData = { playerGold: this.playerGold, aiGold: this.aiGold, entities: entityData, timestamp: Date.now() };
                    // Store in localStorage
                    localStorage.setItem('stickFigureBattleSave', JSON.stringify(saveData));
                    this.showMessage("Game Saved!", 1500); console.log("Game saved.");
                 } catch (error) { console.error("Error saving game:", error); this.showMessage("Error saving game!", 1500); }
            }
            // Load game state from localStorage
            loadGame() {
                 try {
                    const savedData = localStorage.getItem('stickFigureBattleSave');
                    if (savedData) {
                        const parsedData = JSON.parse(savedData); console.log("Loading game data:", parsedData); // DEBUG
                        // Stop current game before loading
                        if (this.gameLoopRequestId) cancelAnimationFrame(this.gameLoopRequestId); if (this.aiTimer) clearInterval(this.aiTimer); this.gameOver = true;
                        // Restore game state
                        this.playerGold = parsedData.playerGold ?? CONFIG.STARTING_GOLD; this.aiGold = parsedData.aiGold ?? CONFIG.AI_STARTING_GOLD;
                        this.entities = []; this.projectiles = []; this.selectedUnits = []; this.buildingToPlace = null; this.unitToTrain = null;
                        // Recreate entities from saved data
                        if (parsedData.entities && Array.isArray(parsedData.entities)) {
                            parsedData.entities.forEach(savedEntity => { if (!savedEntity || !savedEntity.type) return; let entity = null; try { if (CONFIG.UNIT_STATS[savedEntity.type]) { entity = new Unit(savedEntity.x, savedEntity.y, savedEntity.owner, savedEntity.type); entity.state = savedEntity.state || 'idle'; } else if (CONFIG.BUILDING_STATS[savedEntity.type]) { entity = new Building(savedEntity.x, savedEntity.y, savedEntity.owner, savedEntity.type); } if (entity) { entity.hp = savedEntity.hp ?? 1; this.entities.push(entity); } } catch (err) { console.error("Error creating entity during load:", savedEntity, err); } });
                        } else { console.warn("No valid entity data found in save file."); }
                        // Update UI and restart game
                        this.updateResourceDisplay(); this.clearButtonSelections(); this.hideMessage();
                        this.gameOver = false; // Resume game
                        this.aiTimer = setInterval(() => this.runAI(), CONFIG.AI_TRAIN_INTERVAL);
                        this.lastTimestamp = performance.now();
                        this.gameLoopRequestId = requestAnimationFrame((ts) => this.gameLoop(ts)); // Restart loop
                        this.showMessage("Game Loaded!", 1500); console.log(`Game loaded. Entities: ${this.entities.length}`);
                    } else { this.showMessage("No save data found.", 1500); console.log("No save data found."); } // DEBUG
                 } catch (error) { console.error("Error loading game:", error); this.showMessage("Error loading game! Resetting.", 2500); this.resetGame(); } // Reset on error
             }
        }

        // --- Initialize Game ---
        let game = null; // Global game instance reference
        // Wait for the DOM to be fully loaded before initializing the game
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded."); // DEBUG
            try {
                game = new Game('gameCanvas'); // Create the game instance
                // Game loop is started within game.resetGame()
            } catch (error) {
                // Catch initialization errors
                console.error("Failed to initialize game:", error);
                alert("Fatal Error: Could not initialize the game. Check the console for details.");
            }
        });
        console.log("Script execution finished."); // DEBUG

    </script>
</body>
</html>
