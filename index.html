<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medieval Stick Figure Battle</title>
    <style>
        /* CSS Styles remain the same */
        body { font-family: 'Arial', sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; background-color: #f0f0f0; color: #333; touch-action: none; }
        #game-container { display: flex; flex-direction: column; align-items: center; margin-top: 10px; border: 1px solid #ccc; background-color: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: relative; width: 95%; max-width: 900px; }
        #ui-top { width: 100%; padding: 10px; background-color: #e0e0e0; border-bottom: 1px solid #ccc; box-sizing: border-box; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 5px; }
        #resource-display { font-weight: bold; }
        #difficulty-settings button.active { background-color: #6a5acd; border-color: #483d8b; }
        #gameCanvas { border: 1px solid #000; cursor: crosshair; background-color: #fafad2; display: block; width: 100%; height: auto; max-height: 600px; aspect-ratio: 800 / 500; }
        #ui-bottom { width: 100%; padding: 10px; background-color: #e0e0e0; border-top: 1px solid #ccc; box-sizing: border-box; display: flex; flex-wrap: wrap; justify-content: center; gap: 5px; }
        button { padding: 8px 15px; cursor: pointer; background-color: #a9a9a9; color: white; border: 1px solid #808080; border-radius: 5px; font-size: 0.9em; transition: background-color 0.2s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        button:hover { background-color: #8c8c8c; }
        button:active { background-color: #707070; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); }
        button.selected { background-color: #6a5acd; border-color: #483d8b; }
        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px 40px; border-radius: 10px; font-size: 1.5em; text-align: center; z-index: 100; display: none; }
        #save-load button { margin-left: 10px; background-color: #4682b4; border-color: #4169e1; }
        #save-load button:hover { background-color: #5f9ea0; }
        #difficulty-settings { margin-left: auto; }
        #difficulty-settings span { margin-right: 5px; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Medieval Stick Figure Battle</h1>
    <div id="game-container">
        <div id="ui-top">
            <div id="resource-display">Gold: 100</div>
            <div id="save-load"> <button onclick="game.saveGame()">Save</button> <button onclick="game.loadGame()">Load</button> <button onclick="game.resetGame()">Reset</button> </div>
            <div id="difficulty-settings"> <span>Difficulty:</span> <button id="diff-easy" onclick="game.setDifficulty('Easy')">Easy</button> <button id="diff-normal" onclick="game.setDifficulty('Normal')" class="active">Normal</button> <button id="diff-hard" onclick="game.setDifficulty('Hard')">Hard</button> </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="ui-bottom"> <button id="build-worker-btn" onclick="game.selectTrainUnit('Worker')">Train Worker (10G)</button> <button id="build-soldier-btn" onclick="game.selectTrainUnit('Soldier')">Train Soldier (20G)</button> <button id="build-archer-btn" onclick="game.selectTrainUnit('Archer')">Train Archer (25G)</button> <button id="build-wall-btn" onclick="game.selectBuild('Wall')">Build Wall (15G)</button> <button id="build-tower-btn" onclick="game.selectBuild('Tower')">Build Tower (50G)</button> <button id="build-barracks-btn" onclick="game.selectBuild('Barracks')">Build Barracks (75G)</button> <button id="build-mine-btn" onclick="game.selectBuild('Mine')">Build Mine (40G)</button> </div>
        <div id="message-box">Game Over!</div>
    </div>

    <script>
        // alert("Script Started! Check console filters if logs are missing.");

        console.log("Script execution started.");

        // --- Game Configuration --- (Remains the same)
        const CONFIG = { CANVAS_WIDTH: 800, CANVAS_HEIGHT: 500, UNIT_SIZE: 10, BUILDING_BASE_SIZE: 30, UNIT_COLORS: { player: { Worker: 'blue', Soldier: 'dodgerblue', Archer: 'darkblue' }, ai: { Worker: 'red', Soldier: 'orangered', Archer: 'maroon' } }, BUILDING_COLOR_PLAYER: 'darkblue', BUILDING_COLOR_AI: 'darkred', SELECTION_COLOR: 'lime', HEALTH_BAR_COLOR: 'green', HEALTH_BAR_BACKGROUND: 'grey', HEALTH_BAR_HEIGHT: 4, BUILD_PREVIEW_COLOR: 'rgba(0, 255, 0, 0.5)', WALL_DRAG_PREVIEW_COLOR: 'rgba(100, 100, 100, 0.5)', STARTING_GOLD: 100, MINE_GOLD_RATE: 1, RESOURCE_INTERVAL: 2000, UNIT_STATS: { Worker: { cost: 10, hp: 25, speed: 1.5, attack: 1, range: 5, type: 'worker' }, Soldier: { cost: 20, hp: 50, speed: 1, attack: 5, range: 15, type: 'melee' }, Archer: { cost: 25, hp: 30, speed: 1.2, attack: 3, range: 80, type: 'ranged' } }, BUILDING_STATS: { Base: { cost: 0, hp: 500, size: 40, provides_workers: true }, Wall: { cost: 15, hp: 100, size: 15, color: 'grey' }, Tower: { cost: 50, hp: 150, size: 25, color: 'saddlebrown', attack: 4, range: 100, attack_speed: 1500 }, Barracks: { cost: 75, hp: 120, size: 35, color: 'olive', enables_combat_units: true }, Mine: { cost: 40, hp: 80, size: 30, color: 'gold', is_mine: true } }, BUILDING_PLACEMENT_DISTANCE: 2, UNIT_SEPARATION_DISTANCE: 5, AI_BASE_INTERVALS: { train: 8000 }, AI_ACTION_PROBABILITY: { build_check: 0.15, attack_check: 0.25 }, AI_DIFFICULTY_MODIFIERS: { Easy: { interval_multiplier: 1.5, attack_units_min: 3, prob_multiplier: 0.7 }, Normal: { interval_multiplier: 1.0, attack_units_min: 5, prob_multiplier: 1.0 }, Hard: { interval_multiplier: 0.7, attack_units_min: 8, prob_multiplier: 1.3 } }, ATTACK_INTERVAL: 1000, PROJECTILE_SPEED: 5, PROJECTILE_COLOR: 'black', PROJECTILE_SIZE: 3, GAME_SPEED: 16 };

        // --- Utility Functions --- (Remain the same)
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function isColliding(rect1, rect2) { return ( rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y ); }
        function getPointsOnLine(x1, y1, x2, y2, segmentLength) { const points = []; const totalDist = distance(x1, y1, x2, y2); if (totalDist < segmentLength / 2) return [{ x: x1, y: y1 }]; const numSegments = Math.max(1, Math.floor(totalDist / segmentLength)); const dx = (x2 - x1) / totalDist; const dy = (y2 - y1) / totalDist; for (let i = 0; i <= numSegments; i++) { const segmentDist = Math.min(i * segmentLength, totalDist); points.push({ x: x1 + dx * segmentDist, y: y1 + dy * segmentDist }); } return points; }

        // --- Game Classes ---
        class Entity { // Base class - constructor and methods remain the same
            constructor(x, y, width, height, hp, owner, id_prefix = 'e') { this.id = `${id_prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`; this.x = x; this.y = y; this.width = width; this.height = height; this.maxHp = hp; this.hp = hp; this.owner = owner; this.selected = false; }
            draw(ctx) { } update(deltaTime, gameEntities, projectiles) { } getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; } getBoundingBox() { return { x: this.x, y: this.y, width: this.width, height: this.height }; } takeDamage(amount) { this.hp -= amount; if (this.hp <= 0) { this.hp = 0; return true; } return false; } drawHealthBar(ctx) { if (this.hp < this.maxHp && this.hp > 0) { const barWidth = this.width; const barX = this.x; const barY = this.y - CONFIG.HEALTH_BAR_HEIGHT - 2; const hpRatio = this.hp / this.maxHp; ctx.fillStyle = CONFIG.HEALTH_BAR_BACKGROUND; ctx.fillRect(barX, barY, barWidth, CONFIG.HEALTH_BAR_HEIGHT); ctx.fillStyle = CONFIG.HEALTH_BAR_COLOR; ctx.fillRect(barX, barY, barWidth * hpRatio, CONFIG.HEALTH_BAR_HEIGHT); } }
        }

        class Unit extends Entity { // Constructor, state machine, findTarget, performAttack remain the same
            constructor(x, y, owner, type) { const stats = CONFIG.UNIT_STATS[type]; if (!stats) { throw new Error(`Invalid unit type: ${type}`); } super(x, y, CONFIG.UNIT_SIZE, CONFIG.UNIT_SIZE * 2, stats.hp, owner, type.charAt(0).toLowerCase()); this.type = type; this.stats = stats; this.target = null; this.state = 'idle'; this.attackCooldown = 0; this.miningCooldown = 0; this.color = CONFIG.UNIT_COLORS[owner]?.[type] || (owner === 'player' ? 'grey' : 'black'); }
            setTarget(target) { this.target = target; if (target && typeof target.x !== 'undefined' && typeof target.y !== 'undefined') { if (target instanceof Entity) { if (this.type === 'Worker' && target.stats?.is_mine && target.owner === this.owner) { this.state = 'moving_to_mine'; } else if (target.owner !== this.owner) { this.state = 'moving_to_attack'; } else { this.state = 'moving'; } } else { this.state = 'moving'; } } else { this.state = 'idle'; this.target = null; } }
            update(deltaTime, gameEntities, projectiles) { this.attackCooldown = Math.max(0, this.attackCooldown - deltaTime); this.miningCooldown = Math.max(0, this.miningCooldown - deltaTime); switch (this.state) { case 'idle': if (this.type !== 'Worker') { this.findTarget(gameEntities); } break; case 'moving': if (!this.target) { this.state = 'idle'; break; } const targetPosMove = this.target instanceof Entity ? this.target.getCenter() : this.target; this.moveTowards(targetPosMove.x, targetPosMove.y, gameEntities); if (distance(this.getCenter().x, this.getCenter().y, targetPosMove.x, targetPosMove.y) < this.stats.speed + 1) { this.state = 'idle'; this.target = null; } break; case 'moving_to_mine': if (!this.target || this.target.hp <= 0 || !this.target.stats?.is_mine) { this.state = 'idle'; this.target = null; break; } const mineCenter = this.target.getCenter(); if (distance(this.getCenter().x, this.getCenter().y, mineCenter.x, mineCenter.y) < this.target.width / 2 + this.width) { this.state = 'mining'; if(this.owner === 'ai') console.log(`AI: Worker ${this.id} reached mine ${this.target.id}, switching to mining state.`); } else { this.moveTowards(mineCenter.x, mineCenter.y, gameEntities); } break; case 'mining': if (!this.target || this.target.hp <= 0 || !this.target.stats?.is_mine) { this.state = 'idle'; this.target = null; break; } if (this.miningCooldown <= 0) { game.addGold(CONFIG.MINE_GOLD_RATE, this.owner); this.miningCooldown = CONFIG.RESOURCE_INTERVAL; } break; case 'moving_to_attack': if (!this.target || this.target.hp <= 0 || this.target.owner === this.owner) { this.state = 'idle'; this.target = null; this.findTarget(gameEntities); break; } const targetCenterMoveAttack = this.target.getCenter(); const distToTargetMoveAttack = distance(this.getCenter().x, this.getCenter().y, targetCenterMoveAttack.x, targetCenterMoveAttack.y); if (distToTargetMoveAttack <= this.stats.range - this.width / 2) { this.state = 'attacking'; } else { this.moveTowards(targetCenterMoveAttack.x, targetCenterMoveAttack.y, gameEntities); } break; case 'attacking': if (!this.target || this.target.hp <= 0 || this.target.owner === this.owner) { this.state = 'idle'; this.target = null; this.findTarget(gameEntities); break; } const targetCenterAttack = this.target.getCenter(); const distToTargetAttack = distance(this.getCenter().x, this.getCenter().y, targetCenterAttack.x, targetCenterAttack.y); if (distToTargetAttack > this.stats.range) { this.state = 'moving_to_attack'; break; } if (this.attackCooldown <= 0) { this.performAttack(projectiles); this.attackCooldown = CONFIG.ATTACK_INTERVAL; } break; } }
            findTarget(entities) { if (this.state !== 'idle') return; let closestEnemy = null; let minDistance = Infinity; const sightRange = this.stats.range * 2.5; entities.forEach(entity => { if (entity.owner !== this.owner && entity.hp > 0 && (entity instanceof Unit || entity instanceof Building)) { const d = distance(this.getCenter().x, this.getCenter().y, entity.getCenter().x, entity.getCenter().y); if (d < sightRange && d < minDistance) { minDistance = d; closestEnemy = entity; } } }); if (closestEnemy) { this.setTarget(closestEnemy); } }

            // --- MODIFIED moveTowards: Checks collision vs Buildings too ---
            moveTowards(targetX, targetY, gameEntities) {
                const moveSpeed = this.stats.speed;
                const center = this.getCenter();
                const dx = targetX - center.x;
                const dy = targetY - center.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > moveSpeed) {
                    const desiredMoveX = (dx / dist) * moveSpeed;
                    const desiredMoveY = (dy / dist) * moveSpeed;

                    const nextX = this.x + desiredMoveX;
                    const nextY = this.y + desiredMoveY;
                    const nextBox = { x: nextX, y: nextY, width: this.width, height: this.height };

                    let collidingObstacle = null;
                    // Check collision with other units AND buildings
                    for (const entity of gameEntities) {
                        if (entity !== this && entity.getBoundingBox) { // Check against all other entities
                            // Special check for units vs units, units vs buildings
                            if (entity instanceof Unit || entity instanceof Building) {
                                if (isColliding(nextBox, entity.getBoundingBox())) {
                                    collidingObstacle = entity;
                                    break;
                                }
                            }
                        }
                    }

                    if (!collidingObstacle) {
                        // No collision, move normally
                        this.x = nextX;
                        this.y = nextY;
                    } else {
                        // Collision detected, try to slide
                        const obstacleCenter = collidingObstacle.getCenter();
                        const pushX = center.x - obstacleCenter.x;
                        const pushY = center.y - obstacleCenter.y;
                        const pushDist = Math.sqrt(pushX * pushX + pushY * pushY);

                        let slideX = 0; let slideY = 0;
                        if (pushDist > 0.1) {
                            const normPushX = pushX / pushDist; const normPushY = pushY / pushDist;
                            slideX = -normPushY; slideY = normPushX; // Perpendicular vector
                        } else { // If perfectly overlapped, slide randomly
                            const randomAngle = Math.random() * Math.PI * 2; slideX = Math.cos(randomAngle); slideY = Math.sin(randomAngle);
                        }

                        const slideMoveX = slideX * moveSpeed * 0.8; // Slide slightly slower
                        const slideMoveY = slideY * moveSpeed * 0.8;
                        const slideNextX = this.x + slideMoveX; const slideNextY = this.y + slideMoveY;
                        const slideNextBox = { x: slideNextX, y: slideNextY, width: this.width, height: this.height };

                        let slideCollision = false;
                        // Check if slide position is also blocked by units or buildings
                        for (const entity of gameEntities) {
                           if (entity !== this && (entity instanceof Unit || entity instanceof Building) && entity.getBoundingBox) {
                               if (isColliding(slideNextBox, entity.getBoundingBox())) {
                                   slideCollision = true;
                                   break;
                               }
                           }
                        }

                        if (!slideCollision) { // Move if slide path clear
                           this.x = slideNextX; this.y = slideNextY;
                        }
                        // If slide is also blocked, unit effectively stops this frame
                    }
                }
                // Clamp position to stay within canvas bounds
                this.x = Math.max(0, Math.min(CONFIG.CANVAS_WIDTH - this.width, this.x));
                this.y = Math.max(0, Math.min(CONFIG.CANVAS_HEIGHT - this.height, this.y));
            }

            performAttack(projectiles) { if (!this.target || this.target.hp <= 0) return; if (this.stats.type === 'ranged') { const startPos = this.getCenter(); const targetPos = this.target.getCenter(); if (projectiles && typeof projectiles.push === 'function') { projectiles.push(new Projectile(startPos.x, startPos.y, targetPos.x, targetPos.y, this.stats.attack, this.owner, this.target)); } else { console.error("Projectiles array is invalid in performAttack"); } } else { const isDead = this.target.takeDamage(this.stats.attack); if (isDead) { this.state = 'idle'; this.target = null; } } }

            // --- MODIFIED draw method to add combat indicator ---
            draw(ctx) {
                if (!ctx) { return; }
                // Draw basic body (same as before)
                ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.beginPath();
                const headRadius = this.width / 2; const bodyTopY = this.y + headRadius * 2; const bodyBottomY = this.y + this.height * 0.8; const neckY = this.y + headRadius; const centerX = this.x + headRadius; const armY = this.y + this.height * 0.5; const handX = this.x + this.width;
                ctx.arc(centerX, neckY, headRadius, 0, Math.PI * 2); ctx.moveTo(centerX, bodyTopY); ctx.lineTo(centerX, bodyBottomY); ctx.moveTo(centerX, bodyBottomY); ctx.lineTo(this.x, this.y + this.height); ctx.moveTo(centerX, bodyBottomY); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.moveTo(this.x, armY); ctx.lineTo(handX, armY); ctx.stroke();
                // Draw weapons (same as before)
                ctx.strokeStyle = 'grey'; ctx.lineWidth = 1.5; ctx.beginPath(); if (this.type === 'Soldier') { const spearLength = this.height * 0.8; const spearEndX = handX + spearLength * 0.707; const spearEndY = armY - spearLength * 0.707; ctx.moveTo(handX, armY); ctx.lineTo(spearEndX, spearEndY); ctx.moveTo(spearEndX, spearEndY); ctx.lineTo(spearEndX - 5, spearEndY - 2); ctx.moveTo(spearEndX, spearEndY); ctx.lineTo(spearEndX - 2, spearEndY - 5); } else if (this.type === 'Archer') { const bowRadius = this.height * 0.4; ctx.arc(handX - bowRadius * 0.2, armY, bowRadius, Math.PI * 1.3, Math.PI * 0.7, true); } ctx.stroke();

                // --- NEW: Combat Indicator ---
                if (this.state === 'attacking') {
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', centerX, this.y - 5); // Draw exclamation mark above head
                }

                // Health bar and selection indicator (same as before)
                this.drawHealthBar(ctx);
                if (this.selected) { ctx.strokeStyle = CONFIG.SELECTION_COLOR; ctx.lineWidth = 1; ctx.strokeRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4); }
                // Target line (same as before)
                if ((this.state === 'moving' || this.state === 'moving_to_attack' || this.state === 'moving_to_mine') && this.target) { ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.getCenter().x, this.getCenter().y); const targetPosLine = this.target instanceof Entity ? this.target.getCenter() : this.target; ctx.lineTo(targetPosLine.x, targetPosLine.y); ctx.stroke(); }
            }
        }
        class Building extends Entity { // Building class - constructor, update, draw remain the same
            constructor(x, y, owner, type) { const stats = CONFIG.BUILDING_STATS[type]; if (!stats) { throw new Error(`Invalid building type: ${type}`); } super(x, y, stats.size, stats.size, stats.hp, owner, type.charAt(0).toLowerCase()); this.type = type; this.stats = stats; this.color = stats.color || (owner === 'player' ? CONFIG.BUILDING_COLOR_PLAYER : CONFIG.BUILDING_COLOR_AI); this.is_mine = stats.is_mine ?? false; this.provides_workers = stats.provides_workers ?? false; this.enables_combat_units = stats.enables_combat_units ?? false; this.attackCooldown = 0; }
            update(deltaTime, gameEntities, projectiles) { if (this.type === 'Tower' && this.hp > 0 && this.stats.attack && this.stats.range) { this.attackCooldown = Math.max(0, this.attackCooldown - deltaTime); if (this.attackCooldown <= 0) { let target = null; let minDist = this.stats.range; gameEntities.forEach(entity => { if (entity instanceof Unit && entity.owner !== this.owner && entity.hp > 0) { const d = distance(this.getCenter().x, this.getCenter().y, entity.getCenter().x, entity.getCenter().y); if (d < minDist) { minDist = d; target = entity; } } }); if (target) { const startPos = this.getCenter(); const targetPos = target.getCenter(); if (projectiles && typeof projectiles.push === 'function') { projectiles.push(new Projectile(startPos.x, startPos.y, targetPos.x, targetPos.y, this.stats.attack, this.owner, target)); this.attackCooldown = this.stats.attack_speed || 1500; } } } } }
            draw(ctx) { if (!ctx) { return; } ctx.fillStyle = this.color; ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); ctx.fillStyle = 'white'; ctx.font = '10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; let symbol = '?'; switch(this.type) { case 'Base': symbol = 'B'; break; case 'Wall': symbol = ''; break; case 'Tower': symbol = 'T'; break; case 'Barracks': symbol = 'R'; break; case 'Mine': symbol = 'M'; break; default: symbol = this.type.charAt(0); } if (symbol) { ctx.fillText(symbol, this.x + this.width / 2, this.y + this.height / 2); } this.drawHealthBar(ctx); if (this.selected) { ctx.strokeStyle = CONFIG.SELECTION_COLOR; ctx.lineWidth = 1; ctx.strokeRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4); } }
        }
        class Projectile extends Entity { // Projectile class - constructor, update, draw remain the same
             constructor(startX, startY, targetX, targetY, damage, owner, targetEntity) { super(startX, startY, CONFIG.PROJECTILE_SIZE, CONFIG.PROJECTILE_SIZE, 1, owner, 'p'); this.damage = damage; this.startX = startX; this.startY = startY; this.targetEntity = targetEntity; const dx = targetX - startX; const dy = targetY - startY; const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy)); this.velocityX = (dx / dist) * CONFIG.PROJECTILE_SPEED; this.velocityY = (dy / dist) * CONFIG.PROJECTILE_SPEED; this.color = CONFIG.PROJECTILE_COLOR; this.maxRange = 2000; }
             update(deltaTime, gameEntities, projectiles) { this.x += this.velocityX; this.y += this.velocityY; if (this.targetEntity && this.targetEntity.hp > 0) { if (isColliding(this.getBoundingBox(), this.targetEntity.getBoundingBox())) { this.targetEntity.takeDamage(this.damage); this.hp = 0; return; } } const distTraveled = distance(this.startX, this.startY, this.x, this.y); if (this.x < -this.width || this.x > CONFIG.CANVAS_WIDTH || this.y < -this.height || this.y > CONFIG.CANVAS_HEIGHT || distTraveled > this.maxRange) { this.hp = 0; } }
             draw(ctx) { if (!ctx) { return; } ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2); ctx.fill(); }
        }

        // --- Main Game Class ---
        class Game { // Constructor, attachInputHandlers, setCanvasResolution remain the same
            constructor(canvasId) { console.log("Initializing Game class..."); this.canvas = document.getElementById(canvasId); if (!this.canvas) { alert(`Fatal Error: Canvas element with ID "${canvasId}" not found! Check the HTML.`); return; } this.ctx = this.canvas.getContext('2d'); if (!this.ctx) { alert(`Fatal Error: Failed to get 2D context for canvas "${canvasId}"! Your browser might not support Canvas.`); return; } this.resourceDisplay = document.getElementById('resource-display'); this.messageBox = document.getElementById('message-box'); this.buildButtons = { Wall: document.getElementById('build-wall-btn'), Tower: document.getElementById('build-tower-btn'), Barracks: document.getElementById('build-barracks-btn'), Mine: document.getElementById('build-mine-btn'), }; this.trainButtons = { Worker: document.getElementById('build-worker-btn'), Soldier: document.getElementById('build-soldier-btn'), Archer: document.getElementById('build-archer-btn'), }; this.difficultyButtons = { Easy: document.getElementById('diff-easy'), Normal: document.getElementById('diff-normal'), Hard: document.getElementById('diff-hard') }; this.entities = []; this.projectiles = []; this.playerGold = 0; this.aiGold = 0; this.selectedUnits = []; this.buildingToPlace = null; this.unitToTrain = null; this.mousePos = { x: 0, y: 0 }; this.isDragging = false; this.dragStartPos = { x: 0, y: 0 }; this.isDraggingWall = false; this.wallDragStartPos = null; this.gameOver = true; this.winner = null; this.aiTimer = null; this.lastTimestamp = 0; this.gameLoopRequestId = null; this.difficulty = 'Normal'; this.setCanvasResolution(); window.addEventListener('resize', () => this.setCanvasResolution()); this.attachInputHandlers(); this.resetGame(); console.log("Game class initialized."); }
            attachInputHandlers() { this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e)); this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e)); this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e)); this.canvas.addEventListener('contextmenu', (e) => e.preventDefault()); }
            setCanvasResolution() { this.canvas.width = CONFIG.CANVAS_WIDTH; this.canvas.height = CONFIG.CANVAS_HEIGHT; }

            // resetGame includes difficulty setup and logging for AI timer
            resetGame() {
                console.log("Resetting game state..."); if (this.gameLoopRequestId) cancelAnimationFrame(this.gameLoopRequestId); if (this.aiTimer) { console.log(`DEBUG: Clearing existing AI timer ID: ${this.aiTimer}`); clearInterval(this.aiTimer); this.aiTimer = null; }
                this.entities = []; this.projectiles = []; this.playerGold = CONFIG.STARTING_GOLD; this.selectedUnits = []; this.buildingToPlace = null; this.unitToTrain = null; this.isDraggingWall = false; this.wallDragStartPos = null; this.gameOver = false; this.winner = null;
                const basePlayerGold = CONFIG.STARTING_GOLD; switch (this.difficulty) { case 'Easy': this.aiGold = basePlayerGold; break; case 'Hard': this.aiGold = basePlayerGold * 2; break; case 'Normal': default: this.aiGold = Math.floor(basePlayerGold * 1.5); break; } console.log(`DEBUG: AI Gold Initialized for ${this.difficulty}. Player: ${this.playerGold}, AI: ${this.aiGold}`);
                this.hideMessage(); this.updateResourceDisplay(); this.clearButtonSelections(); this.updateDifficultyButtons();
                try { console.log("DEBUG: Creating Base buildings..."); const playerBaseX = 50; const playerBaseY = CONFIG.CANVAS_HEIGHT / 2 - CONFIG.BUILDING_STATS.Base.size / 2; this.entities.push(new Building(playerBaseX, playerBaseY, 'player', 'Base')); const aiBaseX = CONFIG.CANVAS_WIDTH - 50 - CONFIG.BUILDING_STATS.Base.size; const aiBaseY = CONFIG.CANVAS_HEIGHT / 2 - CONFIG.BUILDING_STATS.Base.size / 2; this.entities.push(new Building(aiBaseX, aiBaseY, 'ai', 'Base')); console.log("DEBUG: Creating initial Workers via tryTrainUnit..."); this.tryTrainUnit('Worker', 'player'); this.tryTrainUnit('Worker', 'player'); this.tryTrainUnit('Worker', 'ai'); this.tryTrainUnit('Worker', 'ai'); console.log(`DEBUG: Initial entities created: ${this.entities.length}`); } catch (error) { console.error("Error creating initial entities:", error); this.showMessage("Error initializing game state!", 5000, true); this.gameOver = true; return; }
                const difficultyMods = CONFIG.AI_DIFFICULTY_MODIFIERS[this.difficulty] || CONFIG.AI_DIFFICULTY_MODIFIERS['Normal']; const aiInterval = (CONFIG.AI_BASE_INTERVALS.train * difficultyMods.interval_multiplier); console.log(`DEBUG: Calculated AI interval: ${aiInterval}`); if (aiInterval && aiInterval > 0 && isFinite(aiInterval)) { console.log("DEBUG: Setting up AI timer..."); this.aiTimer = setInterval(() => this.runAI(), aiInterval); console.log(`AI Timer SET with ID: ${this.aiTimer}, Interval: ${aiInterval.toFixed(0)}ms for ${this.difficulty} difficulty`); } else { console.error(`AI Timer setup FAILED: Invalid interval calculated (${aiInterval})`); }
                this.lastTimestamp = performance.now(); this.gameLoopRequestId = requestAnimationFrame((timestamp) => this.gameLoop(timestamp)); console.log("Game reset complete, loop started.");
            }
            // setDifficulty method remains the same
            setDifficulty(level) { if (!CONFIG.AI_DIFFICULTY_MODIFIERS[level]) { level = 'Normal'; } if (this.difficulty === level && !this.gameOver) return; console.log(`Setting difficulty to: ${level}`); this.difficulty = level; this.updateDifficultyButtons(); this.resetGame(); this.showMessage(`Difficulty set to ${level}. Game Reset.`, 1500); }
            // updateDifficultyButtons method remains the same
            updateDifficultyButtons() { Object.entries(this.difficultyButtons).forEach(([level, button]) => { if (button) { if (level === this.difficulty) { button.classList.add('active'); } else { button.classList.remove('active'); } } }); }
            // getMousePos method remains the same
            getMousePos(event) { const rect = this.canvas.getBoundingClientRect(); const scaleX = this.canvas.width / rect.width; const scaleY = this.canvas.height / rect.height; const clientX = event.touches ? event.touches[0].clientX : event.clientX; const clientY = event.touches ? event.touches[0].clientY : event.clientY; return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY }; }
            // Input handling includes wall drag (remains the same)
            handleMouseDown(event) { if (this.gameOver) return; this.mousePos = this.getMousePos(event); if (event.button === 0) { if (this.buildingToPlace === 'Wall') { this.isDraggingWall = true; this.wallDragStartPos = { ...this.mousePos }; } else { this.isDragging = true; this.dragStartPos = { ...this.mousePos }; } } else if (event.button === 2) { if (this.buildingToPlace || this.isDraggingWall) { this.buildingToPlace = null; this.isDraggingWall = false; this.wallDragStartPos = null; this.clearButtonSelections(); } else if (this.selectedUnits.length > 0) { let targetEntity = null; for (const entity of this.entities) { if (!entity.getBoundingBox) continue; const bb = entity.getBoundingBox(); if (this.mousePos.x >= bb.x && this.mousePos.x <= bb.x + bb.width && this.mousePos.y >= bb.y && this.mousePos.y <= bb.y + bb.height) { targetEntity = entity; break; } } this.selectedUnits.forEach(unit => { if (unit && unit.setTarget) { unit.setTarget(targetEntity || { ...this.mousePos }); } }); } } }
            handleMouseMove(event) { if (this.gameOver || (!this.isDragging && !this.isDraggingWall)) return; this.mousePos = this.getMousePos(event); }
            handleMouseUp(event) { if (this.gameOver) return; this.mousePos = this.getMousePos(event); if (event.button === 0) { if (this.isDraggingWall && this.wallDragStartPos) { this.tryPlaceWallLine(this.wallDragStartPos, this.mousePos); this.isDraggingWall = false; this.wallDragStartPos = null; this.buildingToPlace = null; this.clearButtonSelections(); } else if (this.isDragging && !this.buildingToPlace) { const dragEndPos = this.mousePos; const selectionRect = { x: Math.min(this.dragStartPos.x, dragEndPos.x), y: Math.min(this.dragStartPos.y, dragEndPos.y), width: Math.abs(this.dragStartPos.x - dragEndPos.x), height: Math.abs(this.dragStartPos.y - dragEndPos.y) }; this.deselectAll(); if (selectionRect.width > 5 || selectionRect.height > 5) { this.entities.forEach(entity => { if (entity instanceof Unit && entity.owner === 'player' && entity.getBoundingBox) { if (isColliding(entity.getBoundingBox(), selectionRect)) { entity.selected = true; this.selectedUnits.push(entity); } } }); } else { let clickedEntity = null; for (let i = this.entities.length - 1; i >= 0; i--) { const entity = this.entities[i]; if (!entity.getBoundingBox) continue; const bb = entity.getBoundingBox(); if (this.mousePos.x >= bb.x && this.mousePos.x <= bb.x + bb.width && this.mousePos.y >= bb.y && this.mousePos.y <= bb.y + bb.height) { clickedEntity = entity; break; } } if (clickedEntity && clickedEntity.owner === 'player') { clickedEntity.selected = true; if (clickedEntity instanceof Unit) { this.selectedUnits.push(clickedEntity); } } } this.isDragging = false; } else if (this.buildingToPlace && this.buildingToPlace !== 'Wall') { this.tryPlaceBuilding(this.mousePos.x, this.mousePos.y); } } }
            // deselectAll, clearButtonSelections remain the same
            deselectAll() { this.selectedUnits.forEach(unit => { if(unit) unit.selected = false; }); this.selectedUnits = []; }
            clearButtonSelections() { Object.values(this.buildButtons).forEach(btn => { if(btn) btn.classList.remove('selected'); }); this.buildingToPlace = null; this.unitToTrain = null; }
            // addGold includes AI logging (remains the same)
            addGold(amount, owner) { if (owner === 'player') { this.playerGold += amount; this.updateResourceDisplay(); } else { this.aiGold += amount; console.log(`AI: +${amount} Gold from mining. Total: ${this.aiGold}`); } }
            // spendGold, updateResourceDisplay remain the same
            spendGold(amount, owner) { if (owner === 'player') { if (this.playerGold >= amount) { this.playerGold -= amount; this.updateResourceDisplay(); return true; } } else { if (!isNaN(this.aiGold) && this.aiGold >= amount) { this.aiGold -= amount; return true; } } return false; }
            updateResourceDisplay() { if (this.resourceDisplay) { this.resourceDisplay.textContent = `Gold: ${this.playerGold}`; } }
            // selectBuild, selectTrainUnit remain the same
            selectBuild(type) { if (this.gameOver) return; this.clearButtonSelections(); this.buildingToPlace = type; if(this.buildButtons[type]) { this.buildButtons[type].classList.add('selected'); } }
            selectTrainUnit(type) { if (this.gameOver) return; this.clearButtonSelections(); if(!this.trainButtons[type]) { console.warn(`Button for unit type ${type} not found.`); } this.tryTrainUnit(type); }
            // canPlaceBuilding remains the same
            canPlaceBuilding(type, centerX, centerY) { const stats = CONFIG.BUILDING_STATS[type]; if (!stats) { return false; } const size = stats.size; const buildX = centerX - size / 2; const buildY = centerY - size / 2; const buildingBox = { x: buildX, y: buildY, width: size, height: size }; if (buildingBox.x < 0 || buildingBox.x + size > CONFIG.CANVAS_WIDTH || buildingBox.y < 0 || buildingBox.y + size > CONFIG.CANVAS_HEIGHT) { return false; } for (const entity of this.entities) { if (entity instanceof Building && entity.getCenter) { const existingCenter = entity.getCenter(); const existingSize = entity.width; const minDist = (size / 2) + (existingSize / 2) + CONFIG.BUILDING_PLACEMENT_DISTANCE; const d = distance(centerX, centerY, existingCenter.x, existingCenter.y); if (d < minDist) { return false; } } } return true; }
            // tryPlaceBuilding (single click) remains the same
            tryPlaceBuilding(mouseX, mouseY) { const type = this.buildingToPlace; if (!type || type === 'Wall') return; const stats = CONFIG.BUILDING_STATS[type]; if (!stats) { this.buildingToPlace = null; this.clearButtonSelections(); return; } const buildX = mouseX - stats.size / 2; const buildY = mouseY - stats.size / 2; if (this.canPlaceBuilding(type, mouseX, mouseY)) { if (this.spendGold(stats.cost, 'player')) { this.entities.push(new Building(buildX, buildY, 'player', type)); } else { this.showMessage("Not enough gold!", 1000); } } else { this.showMessage("Cannot build here!", 1000); } this.buildingToPlace = null; this.clearButtonSelections(); }
            // tryPlaceWallLine remains the same
            tryPlaceWallLine(startPos, endPos) { const wallStats = CONFIG.BUILDING_STATS['Wall']; const segmentLength = wallStats.size * 0.9; const wallPoints = getPointsOnLine(startPos.x, startPos.y, endPos.x, endPos.y, segmentLength); if (wallPoints.length === 0) return; const totalCost = wallPoints.length * wallStats.cost; if (this.playerGold < totalCost) { this.showMessage(`Not enough gold for ${wallPoints.length} walls! Need ${totalCost}G.`, 2000); return; } let placedCount = 0; let costSpent = 0; for (const point of wallPoints) { if (this.canPlaceBuilding('Wall', point.x, point.y)) { if (this.spendGold(wallStats.cost, 'player')) { const buildX = point.x - wallStats.size / 2; const buildY = point.y - wallStats.size / 2; this.entities.push(new Building(buildX, buildY, 'player', 'Wall')); placedCount++; costSpent += wallStats.cost; } else { break; } } } if (placedCount === 0 && wallPoints.length > 0) { this.showMessage("Cannot place walls here!", 1500); } else if (placedCount < wallPoints.length) { this.showMessage(`Placed ${placedCount} wall segments. Some locations blocked.`, 2000); } }

            // isSpawnPointOccupied helper function (remains the same)
            isSpawnPointOccupied(x, y) { const checkRadius = CONFIG.UNIT_SIZE; const checkBox = { x: x - checkRadius, y: y - checkRadius, width: checkRadius * 2, height: checkRadius * 2 }; for (const entity of this.entities) { if (entity instanceof Unit && entity.getBoundingBox) { if (isColliding(checkBox, entity.getBoundingBox())) { return true; } } } return false; }

            // tryTrainUnit includes spawn point finding and AI logging
            tryTrainUnit(type, owner = 'player') {
                 const stats = CONFIG.UNIT_STATS[type]; if (!stats) { console.error(`Invalid stats for unit type "${type}"`); return; }
                 let spawner = null; const requiredBuildingType = (type === 'Worker') ? 'Base' : 'Barracks';
                 for (const entity of this.entities) { if (entity instanceof Building && entity.owner === owner && entity.type === requiredBuildingType && entity.hp > 0) { spawner = entity; break; } }
                 if (!spawner) { if (owner === 'player') { this.showMessage(`Need a ${requiredBuildingType} to train ${type}!`, 1500); } else { console.log(`AI: Cannot train ${type}, no ${requiredBuildingType}.`); } return; }
                 if (owner === 'ai') { /* console.log(`AI: Found spawner ${spawner.id} (${spawner.type}) for training ${type}.`); */ } // Reduced logging
                 const currentGold = (owner === 'player' ? this.playerGold : this.aiGold);
                 if (owner === 'ai') { /* console.log(`AI: Checking gold for ${type}. Have ${currentGold}, need ${stats.cost}`); */ } // Reduced logging
                 if (this.spendGold(stats.cost, owner)) {
                    let spawnX = spawner.x + spawner.width / 2; let spawnY = spawner.y + spawner.height + CONFIG.UNIT_SIZE; let foundSpot = false; const maxAttempts = 16; const radius = spawner.width * 0.8;
                    if (!this.isSpawnPointOccupied(spawnX, spawnY)) { foundSpot = true; }
                    else { for (let attempt = 0; attempt < maxAttempts && !foundSpot; attempt++) { const angle = Math.random() * Math.PI * 2; const currentRadius = CONFIG.UNIT_SIZE + Math.random() * radius; let checkX = spawnX + Math.cos(angle) * currentRadius; let checkY = spawnY + Math.sin(angle) * currentRadius; checkX = Math.max(CONFIG.UNIT_SIZE, Math.min(CONFIG.CANVAS_WIDTH - CONFIG.UNIT_SIZE, checkX)); checkY = Math.max(CONFIG.UNIT_SIZE, Math.min(CONFIG.CANVAS_HEIGHT - CONFIG.UNIT_SIZE, checkY)); if (!this.isSpawnPointOccupied(checkX, checkY)) { spawnX = checkX; spawnY = checkY; foundSpot = true; } } }
                    if (!foundSpot) { console.warn(`${owner}: Could not find empty spawn point near ${spawner.id} for ${type}, placing at default.`); spawnX = spawner.x + spawner.width / 2; spawnY = spawner.y + spawner.height + CONFIG.UNIT_SIZE; }
                    const newUnit = new Unit(spawnX, spawnY, owner, type); this.entities.push(newUnit);
                    if (owner === 'ai') console.log(`AI: Successfully trained ${type}.`);
                 } else { if (owner === 'player') { this.showMessage(`Not enough gold for ${type}!`, 1000); } else { console.log(`AI: Failed to train ${type}, not enough gold (Have: ${this.aiGold}G Need: ${stats.cost}G).`); } }
                 if (owner === 'player') { this.clearButtonSelections(); }
            }

            // --- MODIFIED runAI: Added idle worker reassignment ---
            runAI() {
                 if (this.gameOver) return;
                 const difficultyMods = CONFIG.AI_DIFFICULTY_MODIFIERS[this.difficulty] || CONFIG.AI_DIFFICULTY_MODIFIERS['Normal'];
                 const probMultiplier = difficultyMods.prob_multiplier; const minAttackUnits = difficultyMods.attack_units_min;
                 // console.log(`AI: Tick (${this.difficulty}). Gold: ${this.aiGold}`); // DEBUG (Spammy)
                 const aiEntities = this.entities.filter(e => e.owner === 'ai'); const aiUnits = aiEntities.filter(e => e instanceof Unit && e.owner === 'ai'); const aiBuildings = aiEntities.filter(e => e instanceof Building && e.owner === 'ai'); const aiBase = aiBuildings.find(b => b.type === 'Base'); const aiBarracks = aiBuildings.find(b => b.type === 'Barracks'); const aiMines = aiBuildings.filter(b => b.type === 'Mine'); const aiWorkers = aiUnits.filter(u => u.type === 'Worker');

                 // --- AI Actions ---
                 // 1. Assign ALL idle workers to mine (if mines exist)
                 aiWorkers.forEach(worker => {
                     if (worker.state === 'idle' && aiMines.length > 0) {
                         const targetMine = aiMines.find(m => m.hp > 0); // Find *any* valid mine
                         if (targetMine) {
                             // console.log(`AI: Assigning idle worker ${worker.id} to mine ${targetMine.id}.`); // DEBUG (Spammy)
                             worker.setTarget(targetMine);
                         }
                     }
                 });

                 // 2. Build structures (Fixed placement attempt)
                 if (Math.random() < CONFIG.AI_ACTION_PROBABILITY.build_check * probMultiplier) {
                    const mineCost = CONFIG.BUILDING_STATS.Mine.cost; const barracksCost = CONFIG.BUILDING_STATS.Barracks.cost; const shouldBuildMine = aiMines.length === 0 && this.aiGold >= mineCost; const shouldBuildBarracks = !aiBarracks && this.aiGold >= barracksCost; const buildType = shouldBuildMine ? 'Mine' : (shouldBuildBarracks ? 'Barracks' : null);
                    if (buildType && aiBase) {
                        let placed = false; const baseCenter = aiBase.getCenter(); const stats = CONFIG.BUILDING_STATS[buildType]; const cost = stats.cost; let buildCenterX, buildCenterY; const offset = 80;
                        // *** Use negative X offset to place left of base ***
                        if (buildType === 'Mine') { buildCenterX = baseCenter.x - offset; buildCenterY = baseCenter.y - offset; }
                        else { buildCenterX = baseCenter.x - offset; buildCenterY = baseCenter.y + offset; } // Barracks

                        // console.log(`AI: Attempting fixed placement for ${buildType} near (${buildCenterX.toFixed(0)}, ${buildCenterY.toFixed(0)})`); // DEBUG
                        if (this.canPlaceBuilding(buildType, buildCenterX, buildCenterY)) {
                            // console.log(`AI: Placement valid for ${buildType}. Spending ${cost}G...`); // DEBUG
                            if (this.spendGold(cost, 'ai')) { const buildX = buildCenterX - stats.size / 2; const buildY = buildCenterY - stats.size / 2; this.entities.push(new Building(buildX, buildY, 'ai', buildType)); placed = true; console.log(`AI: Successfully placed ${buildType}.`); }
                            else { console.log(`AI: Placement valid but failed to spend ${cost}G for ${buildType} (Current Gold: ${this.aiGold}).`); }
                        } else { console.log(`AI: Fixed placement invalid for ${buildType}.`); }
                    }
                 }
                 // 3. Train units
                 const workerCost = CONFIG.UNIT_STATS.Worker.cost; const soldierCost = CONFIG.UNIT_STATS.Soldier.cost; const workerCount = aiWorkers.length; const combatUnitCount = aiUnits.length - workerCount;
                 if (workerCount < 5 && this.aiGold >= workerCost) { this.tryTrainUnit('Worker', 'ai'); }
                 else if (aiBarracks && combatUnitCount < 15 && this.aiGold >= soldierCost) { this.tryTrainUnit('Soldier', 'ai'); }
                 // 4. Attack check
                 if (Math.random() < CONFIG.AI_ACTION_PROBABILITY.attack_check * probMultiplier) {
                     const combatUnits = aiUnits.filter(u => u.type !== 'Worker' && u.state === 'idle');
                     if (combatUnits.length >= minAttackUnits) { console.log(`AI: Launching attack wave! (${combatUnits.length} units)`); const playerBase = this.entities.find(e => e.owner === 'player' && e.type === 'Base'); const targetPos = playerBase ? playerBase.getCenter() : { x: 50, y: CONFIG.CANVAS_HEIGHT / 2 }; combatUnits.forEach(unit => { if (unit && unit.setTarget) { unit.setTarget(targetPos); } }); }
                 }
            }

            // update, checkEndGame, render methods remain the same
            update(deltaTime) { if (this.gameOver) return; this.entities.forEach(entity => { if (entity && entity.update) { entity.update(deltaTime, this.entities, this.projectiles); } }); this.projectiles.forEach(p => { if (p && p.update) { p.update(deltaTime, this.entities, this.projectiles); } }); this.entities = this.entities.filter(entity => entity && entity.hp > 0); this.projectiles = this.projectiles.filter(p => p && p.hp > 0); this.selectedUnits = this.selectedUnits.filter(unit => unit && unit.hp > 0); this.checkEndGame(); }
            checkEndGame() { const playerBase = this.entities.find(e => e.owner === 'player' && e.type === 'Base'); const aiBase = this.entities.find(e => e.owner === 'ai' && e.type === 'Base'); if (!playerBase) { this.endGame('AI'); } else if (!aiBase) { this.endGame('Player'); } }
            render() { if (!this.ctx) return; this.ctx.fillStyle = '#fafad2'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.entities.filter(e => e instanceof Building).forEach(entity => { if (entity && entity.draw) entity.draw(this.ctx); }); this.entities.filter(e => e instanceof Unit).forEach(entity => { if (entity && entity.draw) entity.draw(this.ctx); }); this.projectiles.forEach(p => { if (p && p.draw) p.draw(this.ctx); }); if (this.buildingToPlace && this.buildingToPlace !== 'Wall') { const stats = CONFIG.BUILDING_STATS[this.buildingToPlace]; if (stats) { const previewSize = stats.size; const previewX = this.mousePos.x - previewSize / 2; const previewY = this.mousePos.y - previewSize / 2; const canPlace = this.canPlaceBuilding(this.buildingToPlace, this.mousePos.x, this.mousePos.y); this.ctx.globalAlpha = 0.6; this.ctx.fillStyle = canPlace ? CONFIG.BUILD_PREVIEW_COLOR : 'rgba(255, 0, 0, 0.5)'; this.ctx.fillRect(previewX, previewY, previewSize, previewSize); this.ctx.strokeStyle = canPlace ? 'green' : 'red'; this.ctx.lineWidth = 1; this.ctx.strokeRect(previewX, previewY, previewSize, previewSize); this.ctx.globalAlpha = 1.0; } } else if (this.isDraggingWall && this.wallDragStartPos) { this.ctx.strokeStyle = CONFIG.WALL_DRAG_PREVIEW_COLOR; this.ctx.lineWidth = CONFIG.BUILDING_STATS['Wall'].size; this.ctx.lineCap = 'round'; this.ctx.beginPath(); this.ctx.moveTo(this.wallDragStartPos.x, this.wallDragStartPos.y); this.ctx.lineTo(this.mousePos.x, this.mousePos.y); this.ctx.stroke(); this.ctx.lineCap = 'butt'; } if (this.isDragging && !this.buildingToPlace && !this.isDraggingWall) { this.ctx.strokeStyle = CONFIG.SELECTION_COLOR; this.ctx.lineWidth = 1; this.ctx.strokeRect( this.dragStartPos.x, this.dragStartPos.y, this.mousePos.x - this.dragStartPos.x, this.mousePos.y - this.dragStartPos.y ); } }
            // gameLoop, endGame, showMessage, hideMessage remain the same
            gameLoop(timestamp) { if (this.gameOver) { this.gameLoopRequestId = null; return; } const deltaTime = timestamp - this.lastTimestamp; this.lastTimestamp = timestamp; const effectiveDeltaTime = Math.min(deltaTime, 100); try { this.update(effectiveDeltaTime); this.render(); } catch (error) { console.error("Error in game loop:", error); this.showMessage("An error occurred! See console.", 5000, true); this.gameOver = true; } this.gameLoopRequestId = requestAnimationFrame((ts) => this.gameLoop(ts)); }
            endGame(winner) { if (this.gameOver) return; this.gameOver = true; this.winner = winner; console.log(`Game Over! Winner: ${winner}`); this.showMessage(`${winner} Wins!`, 5000, true); if (this.aiTimer) clearInterval(this.aiTimer); this.aiTimer = null; }
            showMessage(text, duration = 2000, persist = false) { if (this.messageBox) { this.messageBox.textContent = text; this.messageBox.style.display = 'block'; if (!persist) { setTimeout(() => { this.hideMessage(); }, duration); } } else { console.warn("Cannot show message, messageBox element not found."); } }
            hideMessage() { if (this.messageBox) { this.messageBox.style.display = 'none'; } }
            // saveGame, loadGame include difficulty (remain the same)
            saveGame() { if (this.gameOver && this.winner) { this.showMessage("Cannot save finished game", 1500); return; } try { const entityData = this.entities.map(e => { if (!e || !e.type || !e.owner) return null; return { type: e.type, owner: e.owner, x: e.x, y: e.y, hp: e.hp, state: e.state, }; }).filter(e => e !== null); const saveData = { playerGold: this.playerGold, aiGold: this.aiGold, entities: entityData, difficulty: this.difficulty, timestamp: Date.now() }; localStorage.setItem('stickFigureBattleSave', JSON.stringify(saveData)); this.showMessage("Game Saved!", 1500); } catch (error) { console.error("Error saving game:", error); this.showMessage("Error saving game!", 1500); } }
            loadGame() { try { const savedData = localStorage.getItem('stickFigureBattleSave'); if (savedData) { const parsedData = JSON.parse(savedData); if (this.gameLoopRequestId) cancelAnimationFrame(this.gameLoopRequestId); if (this.aiTimer) { console.log(`DEBUG: Clearing existing AI timer ID: ${this.aiTimer} before load.`); clearInterval(this.aiTimer); this.aiTimer = null; } this.gameOver = true; this.playerGold = parsedData.playerGold ?? CONFIG.STARTING_GOLD; this.difficulty = parsedData.difficulty || 'Normal'; if (parsedData.aiGold === undefined || isNaN(parsedData.aiGold)) { console.warn("AI Gold missing or invalid in save data, calculating based on difficulty."); const basePlayerGold = CONFIG.STARTING_GOLD; switch (this.difficulty) { case 'Easy': this.aiGold = basePlayerGold; break; case 'Hard': this.aiGold = basePlayerGold * 2; break; case 'Normal': default: this.aiGold = Math.floor(basePlayerGold * 1.5); break; } } else { this.aiGold = parsedData.aiGold; } console.log(`DEBUG: AI Gold Loaded/Calculated for ${this.difficulty}. AI: ${this.aiGold}`); this.entities = []; this.projectiles = []; this.selectedUnits = []; this.buildingToPlace = null; this.unitToTrain = null; this.isDraggingWall = false; this.wallDragStartPos = null; if (parsedData.entities && Array.isArray(parsedData.entities)) { parsedData.entities.forEach(savedEntity => { if (!savedEntity || !savedEntity.type) return; let entity = null; try { if (CONFIG.UNIT_STATS[savedEntity.type]) { entity = new Unit(savedEntity.x, savedEntity.y, savedEntity.owner, savedEntity.type); entity.state = savedEntity.state || 'idle'; } else if (CONFIG.BUILDING_STATS[savedEntity.type]) { entity = new Building(savedEntity.x, savedEntity.y, savedEntity.owner, savedEntity.type); } if (entity) { entity.hp = savedEntity.hp ?? 1; this.entities.push(entity); } } catch (err) { console.error("Error creating entity during load:", savedEntity, err); } }); } else { console.warn("No valid entity data found in save file."); } this.updateResourceDisplay(); this.clearButtonSelections(); this.updateDifficultyButtons(); this.hideMessage(); this.gameOver = false; const difficultyMods = CONFIG.AI_DIFFICULTY_MODIFIERS[this.difficulty] || CONFIG.AI_DIFFICULTY_MODIFIERS['Normal']; const aiInterval = (CONFIG.AI_BASE_INTERVALS.train * difficultyMods.interval_multiplier); console.log(`DEBUG: Setting up AI timer on load. Interval: ${aiInterval}`); if(aiInterval && aiInterval > 0 && isFinite(aiInterval)) { this.aiTimer = setInterval(() => this.runAI(), aiInterval); console.log(`AI Timer SET with ID: ${this.aiTimer}, Interval: ${aiInterval.toFixed(0)}ms for loaded ${this.difficulty} difficulty`); } else { console.error(`AI Timer setup FAILED on load: Invalid interval calculated (${aiInterval})`); } this.lastTimestamp = performance.now(); this.gameLoopRequestId = requestAnimationFrame((ts) => this.gameLoop(ts)); this.showMessage("Game Loaded!", 1500); } else { this.showMessage("No save data found.", 1500); } } catch (error) { console.error("Error loading game:", error); this.showMessage("Error loading game! Resetting.", 2500); this.resetGame(); } }
        }

        // --- Initialize Game ---
        let game = null;
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded.");
            try { game = new Game('gameCanvas'); }
            catch (error) { console.error("Failed to initialize game:", error); alert("Fatal Error: Could not initialize the game. Check the console for details."); }
        });
        console.log("Script execution finished.");

    </script>
</body>
</html>
